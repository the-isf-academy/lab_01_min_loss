---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.1'
      jupytext_version: 1.2.4
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
# %matplotlib notebook
```

```{python}
import pandas as pd
import matplotlib.pyplot as plt
from helpers import clamp_database, create_graph, draw, draw_line, add_loss, animated_draw, min_loss
import mpld3
mpld3.enable_notebook()
```

# üöø Cleaning up our data

To start out, we're going to pull together our dataset like we did in the last lesson. Just like before, you can change the following variables to determine which columns from our data to use and how to handle outliers.

```{python}
x_var_label = 'grade'
y_var_label = 'sm_time'
x_domain = (5,12)
y_domain = (0,50)
```

```{python}
df = pd.read_csv('social_media_use_clean.csv')
df_two_col = df[[x_var_label, y_var_label]]  # creating new dataframe with only 2 columns
df_two_col = df_two_col.dropna() # removing rows with no response (NaN)
df_two_col_clamp = clamp_database(df_two_col, x_domain, y_domain)  # clamping the dataframe so it fits within the domains
data_points_list = [(x,y) for x, y in df_two_col.values]  # copying data from dataframe to list
```

# üîé Minimizing loss

Last time, we wrote a loss function to help us determine how good our line was at summarizing a potential trend in our data.

```{python}
def loss_one_point(point, m, b):
    point_x, point_y = point
    line_y = m*point_x + b
    residual = point_y - line_y
    return pow(residual,2)

def loss(m,b,data_points_list):
    sqerror = 0
    for point in data_points_list:
        sqerror += loss_one_point(point, m, b)
    return sqerror/len(data_points_list)
```

You played around with a few different lines to try to find the that had the smallest loss.


```{python}
ax = create_graph(x_var_label, y_var_label)
draw(data_points_list, ax, jitter=True)
m = 0
b = 1
draw_line(m, b, ax)
line_loss = loss(m, b, data_points_list)
add_loss(line_loss, ax)
```

But, you could try out different `m` and `b` values for the next 10 years and you still might not find the best ones. 

We need a way to more efficient try out values to try to minimize our loss. Below, we've provided you a function that does just that.

üíª **TODO:** Run the function below to optimize the `m` and `b` values of a trend line for your data.

```{python}
min_m, min_b = min_loss(data_points_list, loss, step_ratio=.01)

print("min_m: {}".format(min_m))
print("min_b: {}".format(min_b))
```

üíª **TODO:** Try plotting the line and the loss using the m and b you found.

```{python}
ax = create_graph(x_var_label, y_var_label)
draw(data_points_list, ax, jitter=True)
m = #PUT MIN HERE
b = #PUT MIN HERE
draw_line(m, b, ax)
line_loss = loss(m, b, data_points_list)
add_loss(line_loss, ax)
```

You might wonder what the min_loss function is doing behind the scenes. Basically, it's search through all the possible `m` and `b` values (to a certain level of granularity) and save the ones that give us the smallest loss.

üíª **TODO:** Run the cell below to see a visualization of this. Greener lines indicate a lower loss while redder lines indicate a higher loss.

```{python}
ax = create_graph(x_var_label, y_var_label)
draw(data_points_list, ax, jitter=True)
step_ratio = .1
xmin, xmax = ax.get_xlim()
for m in range(0,int(1/step_ratio)):
    for b in range(0,int(2/step_ratio)):
        curr_loss = loss(m*step_ratio, b*step_ratio, data_points_list)
        r= min(curr_loss/5, 1)
        g= min(5/curr_loss, 1)
        color_value = (r,g,0.0)
        ax.plot([xmin, xmax], [b*step_ratio + m*step_ratio * xmin, b*step_ratio + m*step_ratio * xmax], alpha=.7, color = color_value)
```

# üë©‚Äçüíª Finding trends in our data üë®‚Äçüíª

Now that you have a way to determine the goodness of a trend line, let's try to find some trends in our data.


## Picking variables

Trying chaning out the variables to one you are interested in exploring

```{python}
df
```

```{python}
x_var_explore = #PICK A COLUMN FOR THE X VARIABLE
y_var_explore = #PICK A COLUMN FOR THE Y VARIABLE
x_domain = (5,12)
y_domain = (0,50)
df_two_col = df[[x_var_explore, y_var_explore]]  # creating new dataframe with only 2 columns
df_two_col = df_two_col.dropna() # removing rows with no response (NaN)
df_two_col_clamp = clamp_database(df_two_col, x_domain, y_domain)  # clamping the dataframe so it fits within the domains
explore_data_list = [(x,y) for x, y in df_two_col.values]  # copying data from dataframe to list
```

## Minimizing Loss

```{python}
min_m, min_b = min_loss(explore_data_list, loss, step_ratio=.1)

print("min_m: {}".format(min_m))
print("min_b: {}".format(min_b))
```

## Plotting the data and the trend line

```{python}
ax = create_graph(x_var_label, y_var_label)
draw(explore_data_list, ax, jitter=True)
draw_line(min_m, min_b, ax)
line_loss = loss(min_m, min_b, explore_data_list)
add_loss(line_loss, ax)
```
